class Getopt
  @HAS_ARGUMENT = true
  @NO_ARGUMENT = false
  @MULTI_SUPPORTED = true
  @SINGLE_ONLY = false

  # private
  save_option_: (options, option, argv) ->
    if option.has_argument
      if argv.length == 0
        throw new Error("option #{option.long_name} needs argument")
      value = argv.shift()
    else
      value = true

    if option.multi_supported
      options[option.name] ?= []
      options[option.name].push value
    else
      options[option.name] = value
    @


  # public
  constructor: (@options) ->
    @short_options = {}
    @long_options  = {}
    @long_names = []

    if process.argv[1]
      @help = "Usage: node #{process.argv[1].match(/(?:.*[\/\\])?(.*)$/)[1]}\n\n[[OPTIONS]]"
    else
      @help = "[[OPTIONS]]"

    for option in @options
      [short_name, long_name, has_argument, multi_supported] = option
      comment = ''

      if typeof(has_argument) == 'string'
        # 3rd param is string
        # ':' has_argument
        # '+' multi_supported
        # '#' comment
        info = has_argument
        info =~ /^(.*?)(?:#(.*))?$/
        comment = \2 ? ''
        info = \1
        multi_supported = info.indexOf('+') != -1
        has_argument =  info.indexOf(':') != -1
      else
        # comptible with v0.1.0
        has_argument = !!has_argument
        multi_supported = !!multi_supported
        comment = ''

      unless long_name
        long_name = short_name

      name = long_name

      unless @long_options[long_name]?
        @long_names.push long_name
        @long_options[long_name] = {name, short_name, long_name, has_argument, multi_supported, comment}
      else
        throw new Error("option #{long_name} redefined.");

      if short_name != ''
        if short_name.length != 1
          throw new Error 'short option must be single characters'
        @short_options[short_name] = @long_options[long_name]
    @

  parse: (argv) ->
    # clone argv
    argv = argv[0..]
    rt_options = {}
    rt_argv = []
    while (arg = argv.shift())?
      if arg =~ /^-(\w[\w\-]*)/
        # short option
        short_names = \1
        for short_name, i in short_names
          option = @short_options[short_name]
          unless option
            throw new Error("invalid option #{short_name}")

          if option.has_argument
            if i < short_names.length - 1
              argv.unshift short_names.slice(i+1)
            @save_option_(rt_options, option, argv)
            break
          else
            @save_option_(rt_options, option, argv)

      else if arg =~ /^--(\w[\w\-]*)((?:=.*)?)$/
        # long option
        long_name = \1
        value     = \2
        if value != ''
          value = value[1..]
          argv.unshift(value)
        option = @long_options[long_name]
        unless option
          throw new Error("invalid option #{long_name}")
        @save_option_(rt_options, option, argv)

      else if arg == '--'
        rt_argv = rt_argv.concat(argv)
        break

      else
        rt_argv.push arg

    {argv: rt_argv, options: rt_options}

  parse_system: ->
    @parse(process.argv.slice(2))

  parseSystem: ->
    @parse_system()

  setHelp: (@help) ->
    @

  getHelp: ->
    ws = []
    options = []

    for long_name in @long_names
      option = @long_options[long_name]
      {short_name, long_name, comment} = option
      if (short_name && short_name == long_name)
        # only has short name
        opt = "-#{short_name}"
      else if short_name
        # both has short name and long name
        opt = "-#{short_name}, --#{long_name}"
      else
        # only has long name
        opt = "    --#{long_name}"
      ws[0] = Math.max(ws[0] >> 0, opt.length)
      options.push [opt, comment]

    strs = for option in options
      [opt, comment] = option
      while opt.length < ws[0]
        opt += ' '
      "  #{opt}  #{comment}"

    @help.replace('[[OPTIONS]]', strs.join("\n"))

  showHelp: ->
    console.info @getHelp()
    @

module.exports = Getopt
