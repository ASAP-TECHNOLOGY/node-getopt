// Generated by ToffeeScript 1.6.3-4
(function() {
  var Getopt, __matches;

  function fix(long_name) {
    return 'o_' + long_name;
  };

  Getopt = (function() {
    Getopt.HAS_ARGUMENT = true;

    Getopt.NO_ARGUMENT = false;

    Getopt.MULTI_SUPPORTED = true;

    Getopt.SINGLE_ONLY = false;

    Getopt.VERSION = '0.2.3';

    function Getopt(optionsPattern) {
      var comment, def, definition, fixed_long_name, has_argument, long_name, multi_supported, name, option, optional, short_name, _i, _len, _ref;
      this.optionsPattern = optionsPattern;
      this.short_options = {};
      this.long_options = {};
      this.long_names = [];
      this.events = {};
      this.argv = [];
      this.options = {};
      this.errorFunc = function(e) {
        console.info(e.message);
        return process.exit(1);
      };
      if (process.argv[1]) {
        this.help = "Usage: node " + (process.argv[1].match(/(?:.*[\/\\])?(.*)$/)[1]) + "\n\n[[OPTIONS]]\n";
      } else {
        this.help = "[[OPTIONS]]";
      }
      _ref = this.optionsPattern;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        short_name = option[0], definition = option[1], comment = option[2], def = option[3];
        if (comment == null) {
          comment = '';
        }
        if (definition == null) {
          definition = '';
        }
        if (short_name == null) {
          short_name = '';
        }
        __matches = definition.match(/^([\w\-]*)/);
        long_name = __matches[1];
        has_argument = definition.indexOf('=') !== -1;
        multi_supported = definition.indexOf('+') !== -1;
        optional = /\[=.*?\]/.test(definition);
        long_name = long_name.trim();
        short_name = short_name.trim();
        if (optional && short_name) {
          throw new Error('optional argument can only work with long option');
        }
        if (!long_name) {
          long_name = short_name;
        }
        fixed_long_name = fix(long_name);
        name = long_name;
        if (long_name === '') {
          throw new Error("empty option found. the last option name is " + (this.long_names.slice(-1)));
        }
        if (this.long_options[fixed_long_name] == null) {
          this.long_names.push(long_name);
          this.long_options[fixed_long_name] = {
            name: name,
            short_name: short_name,
            long_name: long_name,
            has_argument: has_argument,
            multi_supported: multi_supported,
            comment: comment,
            optional: optional,
            definition: definition,
            "default": def
          };
        } else {
          throw new Error("option " + long_name + " is redefined.");
        }
        if (short_name !== '') {
          if (short_name.length !== 1) {
            throw new Error('short option must be single characters');
          }
          this.short_options[short_name] = this.long_options[fixed_long_name];
        }
      }
      this;
    }

    Getopt.prototype.getOptionByName = function(name) {
      var _ref;
      return (_ref = this.long_options[fix(name)]) != null ? _ref : this.short_options[name];
    };

    Getopt.prototype.getOptionName = function(name) {
      var _ref;
      return (_ref = this.getOptionByName(name)) != null ? _ref.name : void 0;
    };

    Getopt.prototype.on = function(name, cb) {
      var iname;
      if (name) {
        iname = this.getOptionName(name);
        if (!iname) {
          throw new Error("unknown option " + name);
        }
      } else {
        iname = name;
      }
      this.events[iname] = cb;
      return this;
    };

    Getopt.prototype.emit = function(name, value) {
      var event;
      event = this.events[this.getOptionName(name)];
      if (event) {
        return event.call(this, value);
      } else {
        throw new Error("Getopt event on '" + name + "' is not found");
      }
    };

    Getopt.prototype.save_option_ = function(options, option, argv) {
      var name, value, _ref;
      if (option.has_argument) {
        if (argv.length === 0) {
          throw new Error("option " + option.long_name + " need argument");
        }
        value = argv.shift();
      } else {
        value = true;
      }
      name = option.name;
      if (option.multi_supported) {
        if (options[name] == null) {
          options[name] = [];
        }
        options[name].push(value);
      } else {
        options[name] = value;
      }
      if ((_ref = this.events[name]) != null) {
        _ref.call(this, value);
      }
      return this;
    };

    Getopt.prototype.parse = function(argv) {
      var arg, e, i, long_name, name, option, rt_argv, rt_options, short_name, short_names, sname, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
      try {
        argv = argv.slice(0);
        rt_options = {};
        rt_argv = [];
        _ref = this.long_names;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          long_name = _ref[_i];
          option = this.long_options[fix(long_name)];
          if ((option["default"] != null) || (rt_options[option.long_name] != null)) {
            rt_options[option.long_name] = option["default"];
          }
        }
        while ((arg = argv.shift()) != null) {
          if (__matches = arg.match(/^-(\w[\w\-]*)/)) {
            short_names = __matches[1];
            for (i = _j = 0, _len1 = short_names.length; _j < _len1; i = ++_j) {
              short_name = short_names[i];
              option = this.short_options[short_name];
              if (!option) {
                throw new Error("invalid option " + short_name);
              }
              if (option.has_argument) {
                if (i < arg.length - 2) {
                  argv.unshift(arg.slice(i + 2));
                }
                this.save_option_(rt_options, option, argv);
                break;
              } else {
                this.save_option_(rt_options, option, argv);
              }
            }
          } else if (__matches = arg.match(/^--(\w[\w\-]*)((?:=[^]*)?)$/)) {
            long_name = __matches[1];
            value = __matches[2];
            option = this.long_options[fix(long_name)];
            if (!option) {
              throw new Error("invalid option " + long_name);
            }
            if (value !== '') {
              value = value.slice(1);
              argv.unshift(value);
            } else if (option.optional) {
              argv.unshift('');
            }
            this.save_option_(rt_options, option, argv);
          } else if (arg === '--') {
            rt_argv = rt_argv.concat(argv);
            for (_k = 0, _len2 = argv.length; _k < _len2; _k++) {
              arg = argv[_k];
              if ((_ref1 = this.events['']) != null) {
                _ref1.call(this, arg);
              }
            }
            break;
          } else {
            rt_argv.push(arg);
            if ((_ref2 = this.events['']) != null) {
              _ref2.call(this, arg);
            }
          }
        }
        _ref3 = Object.keys(rt_options);
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          name = _ref3[_l];
          sname = this.long_options[fix(name)].short_name;
          if (sname !== '') {
            rt_options[sname] = rt_options[name];
          }
        }
      } catch (_error) {
        e = _error;
        this.errorFunc(e);
      }
      this.argv = rt_argv;
      this.options = rt_options;
      return this;
    };

    Getopt.prototype.parse_system = function() {
      return this.parseSystem();
    };

    Getopt.prototype.parseSystem = function() {
      return this.parse(process.argv.slice(2));
    };

    Getopt.prototype.setHelp = function(help) {
      this.help = help;
      return this;
    };

    Getopt.prototype.getHelp = function() {
      var comment, definition, long_name, opt, option, options, short_name, strs, ws, _i, _len, _ref;
      ws = [];
      options = [];
      _ref = this.long_names;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        long_name = _ref[_i];
        option = this.long_options[fix(long_name)];
        short_name = option.short_name, long_name = option.long_name, comment = option.comment, definition = option.definition;
        if (short_name && short_name === long_name) {
          opt = "-" + short_name;
        } else if (short_name) {
          opt = "-" + short_name + ", --" + definition;
        } else {
          opt = "    --" + definition;
        }
        ws[0] = Math.max(ws[0] >> 0, opt.length);
        options.push([opt, comment]);
      }
      strs = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = options.length; _j < _len1; _j++) {
          option = options[_j];
          opt = option[0], comment = option[1];
          while (opt.length < ws[0]) {
            opt += ' ';
          }
          _results.push("  " + opt + "  " + comment);
        }
        return _results;
      })();
      return this.help.replace('[[OPTIONS]]', strs.join("\n"));
    };

    Getopt.prototype.showHelp = function() {
      console.info(this.getHelp());
      return this;
    };

    Getopt.prototype.bindHelp = function(help) {
      if (help) {
        this.setHelp(help);
      }
      this.on('help', function() {
        this.showHelp();
        return process.exit(0);
      });
      return this;
    };

    Getopt.prototype.getVersion = function() {
      return Getopt.VERSION;
    };

    Getopt.prototype.error = function(errorFunc) {
      this.errorFunc = errorFunc;
      return this;
    };

    Getopt.getVersion = function() {
      return this.VERSION;
    };

    Getopt.create = function(options) {
      return new Getopt(options);
    };

    return Getopt;

  })();

  module.exports = Getopt;

}).call(this);
